module Musca
  class CertAuthority
    attr_accessor :config_file, :password
    attr_reader :cfg

    def initialize(*args)
      Hash[*args].each { |k, v| send(format('%s=', k), v) }
      @cfg = OpenStruct.new(YAML.load(File.read(config_file)))
      cfg.dir = File.expand_path(File.dirname(config_file))
      # we were passed a :password in #new
      cfg.ca_password ||= password
      Dir.chdir(cfg.dir) do
        # load certs if they've already been created. silently fail.
        if File.exist?(cfg.ca_cert) && File.exist?(cfg.ca_key)
          cfg.key = OpenSSL::PKey::RSA.new(
            File.read(cfg.ca_key),
            cfg.ca_password
          )
          cfg.cert = OpenSSL::X509::Certificate.new(File.read(cfg.ca_cert))
        end
      end
    end

    def blank_cert(type = 'server')
      init = Time.now
      cert = OpenSSL::X509::Certificate.new
      cert.serial = 1
      cert.version = 2
      cert.not_before = init
      cert.not_after = init + cfg.cert_valid * 365 * 24 * 60 * 60
      populate_extensions(type, cert)
      cert
    end

    def init_keys(cert)
      new_key = gen_pkey
      cert.public_key = new_key.public_key
      new_key
    end


    def create
      basedn = OpenSSL::X509::Name.parse(cfg.base_dn)
      my_dn = basedn.add_entry('CN', 'Musca CA')
      cfg.cert = blank_cert('ca')
      cfg.key = init_keys(cfg.cert)
      cfg.cert.subject = my_dn
      cfg.cert.issuer = my_dn
      cfg.cert.sign(cfg.key, OpenSSL::Digest::SHA256.new)
      # cipher = OpenSSL::Cipher::AES256.new(:CBC)
      Dir.chdir(cfg.dir) do
        File.open(cfg.ca_cert, 'w') { |f| f.write(cfg.cert.to_pem) }
        File.open(cfg.ca_key,  'w') { |f| f.write(cfg.key.to_pem) }
      end
    end

    def newcert(certclass, cn)
      new_dn = OpenSSL::X509::Name.parse(cfg.base_dn)
      new_dn.add_entry('OU', certclass)
      new_dn.add_entry('CN', cn)
      new_cert =            blank_cert(certclass)
      new_cert.subject =    new_dn
      new_cert.public_key = new_key.public_key
      new_cert.issuer =     cfg.cert.subject
      new_cert.serial =     next_serial
      new_cert.sign(cfg.key, OpenSSL::Digest::SHA256.new)
      fname = format('%04x_%s_%s', new_cert.serial, cn, certclass)
      Dir.chdir(cfg.dir) do
        key_name = File.join('keys', format('%s_key.pem', fname))
        File.write(key_name, new_key.to_pem)
        cert_name = File.join('certs', format('%s_cert.pem', fname))
        File.write(cert_name, new_cert.to_pem)
      end
      new_cert
    end

    private

    def populate_extensions(certclass, thing)
      unless cfg.cert_extensions.key? certclass
        fail ArgumentError,
             format('%s certificate type not valid (must be: %s)',
                    certclass,
                    cfg.cert_extensions.keys.join(', '))
      end
      ef = OpenSSL::X509::ExtensionFactory.new
      if thing.is_a? OpenSSL::X509::Request
        ef.subject_request = thing
      elsif thing.is_a? OpenSSL::X509::Certificate
        ef.subject_certificate = thing
      end
      ef.issuer_certificate = cfg.cert
      cfg.cert_extensions[certclass].each do |ext_name, vals|
        thing.add_extension(
          ef.create_extension(
            ext_name,
            vals.join(','),
            cfg.critical[ext_name]
          )
        )
      end
      thing.add_extension(
        ef.create_extension(
          'nsComment',
          "Generated by musca for Musca #{certclass.capitalize}"
        )
      )
    end

    private

    def next_serial
      new_serial = nil
      Dir.chdir(cfg.dir) do
        cur_serial = File.read(cfg.ca_serial).strip.to_i
        new_serial = cur_serial + 1
        File.open(cfg.ca_serial, 'w') { |f| f.write(new_serial) }
      end
      new_serial
    end

    def gen_pkey
      OpenSSL::PKey::RSA.new(cfg.key_length)
    end
  end
end
